<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Javanotes 6.0, Section 10.2 -- Lists and Sets</title>
<link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
<small>
        [  <a href="s1.html">Previous Section</a> |
           <a href="s3.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#generics.2.1">ArrayList and LinkedList</a>
<br>
<a href="#generics.2.2">Sorting</a>
<br>
<a href="#generics.2.3">TreeSet and HashSet</a>
<br>
<a href="#generics.2.4">EnumSet</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content">
<h3 class="section_title">Section 10.2</h3>
<h2 class="section_title">Lists and Sets</h2>
<hr class="break">
   


<p>
<span class="start"><big>I</big>n the previous section</span>, we looked at the general
properties of collection classes in Java. In this section, we look at some
specific collection classes and how to use them. These classes can be divided
into two categories: lists and sets. A list consists of a sequence of items
arranged in a linear order. A list has a definite order, but is not necessarily
sorted into ascending order. A set is a collection that has no duplicate
entries. The elements of a set might or might not be arranged into some
definite order.</p>


<hr class="break">
<h3 class="subsection_title">
<a name="generics.2.1">10.2.1&nbsp;&nbsp;ArrayList and LinkedList</a>
</h3>


<p>There are two obvious ways to represent a list: as a dynamic array and as a
linked list. We've encountered these already in 
<a href="../c7/s3.html">Section&nbsp;7.3</a> and <a href="../c9/s2.html">Section&nbsp;9.2</a>. Both of these
options are available in generic form as the collection classes
<span class="code">java.util.ArrayList</span> and <span class="code">java.util.LinkedList</span>. These
classes are part of the Java Collection Framework.  Each implements the interface
<span class="classname">List&lt;T&gt;</span>, and therefore the interface <span class="classname">Collection&lt;T&gt;</span>.
An object of type <span class="classname">ArrayList&lt;T&gt;</span>
represents an ordered sequence of objects of type <span class="classname">T</span>,
stored in an array that will grow in size whenever necessary as new items are added. An object of type
<span class="classname">LinkedList&lt;T&gt;</span> also
represents an ordered sequence of objects of type <span class="classname">T</span>, but
the objects are stored in nodes that are linked
together with pointers.</p>


<p>Both list classes support the basic list operations that are defined in
the interface <span class="classname">List&lt;T&gt;</span>, and an abstract data
type is defined by its operations, not by its representation. So why two
classes? Why not a single List class with a single representation? The problem
is that there <b>is</b> no single representation of lists for which all list
operations are efficient. For some operations, linked lists are more efficient
than arrays. For others, arrays are more efficient. In a particular application
of lists, it's likely that only a few operations will be used frequently. You
want to choose the representation for which the frequently used operations will
be as efficient as possible.</p>


<p>Broadly speaking, the <span class="classname">LinkedList</span> class is more efficient in
applications where items will often be added or removed at the beginning of the
list or in the middle of the list. In an array, these operations require moving
a large number of items up or down one position in the array, to make a space
for a new item or to fill in the hole left by the removal of an item.  In terms
of asymptotic analysis (<a href="../c8/s5.html">Section&nbsp;8.5</a>), adding an element at the beginning
or in the middle of an array has run time&nbsp;Θ(n), where n is the number
of items in the array.  In a
linked list, nodes can be added or removed at any position by changing a few
pointer values, an operation that has run time Θ(1).  That is, the 
operation takes only some constant amount of time, independent of how many
items are in the list.</p>
   

<p>On the other hand, the <span class="classname">ArrayList</span> class is more efficient when
<span class="newword">random access</span> to items is required.  Random access
means accessing the k-th item in the list, for any integer&nbsp;k.  Random access
is used when you get or change the value stored at a specified position in the list.
This is trivial for an array, with run time Θ(1).  
But for a linked list it means starting at the beginning
of the list and moving from node to node along the list for k steps, an
operation that has run time Θ(k).</p>
   

<p>Operations that can be done efficiently for both types of lists include sorting and adding
an item at the end of the list.</p>


<p>All lists implement the methods from interface <span class="classname">Collection&lt;T&gt;</span> 
that were discussed in <a href="../c10/s1.html#generics.1.4">Subsection&nbsp;10.1.4</a>.  These methods include  <span class="code">size()</span>,
<span class="code">isEmpty()</span>, <span class="code">add(T)</span>, <span class="code">remove(Object)</span>, and
<span class="code">clear()</span>. The <span class="code">add(T)</span> method adds the object at the end of
the list. The <span class="code">remove(Object)</span> method involves first finding the object,
which is not very efficient for any list since it involves going through the
items in the list from beginning to end until the object is found. The interface
<span class="classname">List&lt;T&gt;</span>  adds some methods for accessing list items according to
their numerical positions in the list.  Suppose that <span class="code">list</span> is an object
of type <span class="classname">List&lt;T&gt;</span>.  Then we have the methods:</p>


<ul>

<li>
<span class="codedef">list.get(index)</span>  --  returns the
object of type <span class="classname">T</span> that is
at position <span class="code">index</span> in the list, where <span class="code">index</span> is
an integer. Items are numbered 0, 1, 2, ..., <span class="code">list.size()-1</span>. The
parameter must be in this range, or an <span class="classname">IndexOutOfBoundsException</span> is
thrown.</li>


<li>
<span class="codedef">list.set(index,obj)</span>  --  stores the
object <span class="code">obj</span> at position number <span class="code">index</span> in the list, replacing
the object that was there previously. The object <span class="code">obj</span> must be of
type <span class="classname">T</span>.  This does not change the number of
elements in the list or move any of the other elements.</li>


<li>
<span class="codedef">list.add(index,obj)</span>  --  inserts an
object <span class="code">obj</span> into the list at position number <span class="code">index</span>,
where <span class="code">obj</span> must be of type <span class="classname">T</span>.  The number
of items in the list increases by one, and items that come after position
<span class="code">index</span> move down one position to make room for the new item. The value of
<span class="code">index</span> must be in the range 0 to <span class="code">list.size()</span>, inclusive.
If <span class="code">index</span> is equal to <span class="code">list.size()</span>, then <span class="code">obj</span>
is added at the end of the list.</li>


<li>
<span class="codedef">list.remove(index)</span>  --  removes the
object at position number <span class="code">index</span>, and returns that object
as the return value of the method.
Items after this position move up one
space in the list to fill the hole, and the size of the list decreases by one.
The value of <span class="code">index</span> must be in the range 0 to <span class="code">list.size()-1</span>
</li>


<li>
<span class="codedef">list.indexOf(obj)</span>  --  returns an
<span class="ptype">int</span> that gives the position of <span class="code">obj</span> in the list, if it occurs.
If it does not occur, the return value is <span class="code">-1</span>.  The object <span class="code">obj</span>
can be of any type, not just of type&nbsp;<span class="classname">T</span>.  If <span class="code">obj</span> occurs
more than once in the list, the index of the first occurrence is returned.</li>

</ul>


<p>These methods are defined both in class <span class="classname">ArrayList&lt;T&gt;</span> and in class
<span class="classname">LinkedList&lt;T&gt;</span>, although some of them -- <span class="code">get</span>
and <span class="code">set</span> -- are only efficient for
<span class="classname">ArrayLists</span>. The class <span class="classname">LinkedList&lt;T&gt;</span> adds a few additional
methods, which are not defined for an <span class="classname">ArrayList</span>. If
<span class="code">linkedlist</span> is an object of type <span class="classname">LinkedList&lt;T&gt;</span>, then we have</p>


<ul>

<li>
<span class="codedef">linkedlist.getFirst()</span>  --  returns the
object of type <span class="classname">T</span> that is the first item in the list. The list is not
modified.  If the list is empty when the method is called, an exception of type
<span class="classname">NoSuchElementException</span> is thrown (the same is true for the
next three methods as well).</li>


<li>
<span class="codedef">linkedlist.getLast()</span>  --  returns the
object of type <span class="classname">T</span> that is the last item in the list. The list is not
modified.</li>


<li>
<span class="codedef">linkedlist.removeFirst()</span>  --  removes
the first item from the list, and returns that object of type <span class="classname">T</span> as its return
value.</li>


<li>
<span class="codedef">linkedlist.removeLast()</span>  --  removes
the last item from the list, and returns that object of type <span class="classname">T</span> as its return
value.</li>


<li>
<span class="codedef">linkedlist.addFirst(obj)</span>  --  adds the
<span class="code">obj</span>, which must be of type <span class="classname">T</span>, to the beginning of the list.</li>


<li>
<span class="codedef">linkedlist.addLast(obj)</span>  --  adds the
object <span class="code">obj</span>, which must be of type <span class="classname">T</span>, to the end of the list. 
(This is exactly the same as <span class="code">linkedlist.add(obj)</span> but is defined to keep the
naming consistent.)</li>

</ul>


<p>These methods are apparently defined to make it easy to use a
<span class="classname">LinkedList</span> as if it were a stack or a queue. (See 
<a href="../c9/s3.html">Section&nbsp;9.3</a>.) For example, we can use a
<span class="classname">LinkedList</span> as a queue by adding items onto one end of the list (using
the <span class="code">addLast()</span> method) and removing them from the other end (using the
<span class="code">removeFirst()</span> method).</p>


<p>If <span class="code">list</span> is an object of type <span class="classname">List&lt;T&gt;</span>, then the method
<span class="code">list.iterator()</span>, defined in the interface <span class="classname">Collection&lt;T&gt;</span>, returns
an <span class="classname">Iterator</span> that can be used to traverse the list from beginning to
end. However, for <span class="classname">Lists</span>, there is a special type of <span class="classname">Iterator</span>,
called a <span class="classname">ListIterator</span>, which offers additional capabilities. 
<span class="classname">ListIterator&lt;T&gt;</span> is an interface that extends the
interface <span class="classname">Iterator&lt;T&gt;</span>.  
The method <span class="code">list.listIterator()</span> returns an object of type
<span class="classname">ListIterator&lt;T&gt;</span>.</p>


<p>A <span class="classname">ListIterator</span> has the usual <span class="classname">Iterator</span> methods,
<span class="code">hasNext()</span>, <span class="code">next()</span>, and <span class="code">remove()</span>, but it also has methods
<span class="code">hasPrevious()</span>, <span class="code">previous()</span>, and <span class="code">add(obj)</span>
that make it possible to move backwards in the list and to add an item at the
current position of the iterator.  To understand how these work, it's best to think of an
iterator as pointing to a position <b>between</b> two list elements, or at
the beginning or end of the list. In this diagram, the items in a list are
represented by squares, and arrows indicate the possible positions of an
iterator:</p>


<p align="center">
<img src="listPositions.png" width="357" height="91" alt="Iterator Positions"></p>



<p>If <span class="code">iter</span> is of type <span class="classname">ListIterator&lt;T&gt;</span>, then 
<span class="code">iter.next()</span> moves
the iterator one space to the right along the list and returns the item that
the iterator passes as it moves. The method <span class="code">iter.previous()</span> moves the
iterator one space to the left along the list and returns the item that it
passes. The method <span class="code">iter.remove()</span> removes an item from the list; the
item that is removed is the item that the iterator passed most recently in a
call to either <span class="code">iter.next()</span> or <span class="code">iter.previous()</span>. There is also
a method <span class="code">iter.add(obj)</span> that adds the specified object to the list
at the current position of the iterator (where <span class="code">obj</span> must be of type
<span class="classname">T</span>).  This can be between two existing items
or at the beginning of the list or at the end of the list.</p>


<p>(By the way, the lists that are used in class <span class="code">LinkedList&lt;T&gt;</span> are
<span class="newword">doubly linked lists</span>. That is, each node in the
list contains two pointers -- one to the next node in the list and one to the
previous node. This makes it possible to efficiently implement both the
<span class="code">next()</span> and <span class="code">previous()</span> methods of a <span class="code">ListIterator</span>.
Also, to make the <span class="code">addLast()</span> and <span class="code">getLast()</span> methods of a
<span class="classname">LinkedList</span> efficient, the class <span class="classname">LinkedList&lt;T&gt;</span> 
includes an instance variable that points to the last node in the list.)</p>


<p>As an example of using a <span class="classname">ListIterator</span>, suppose that we want to
maintain a list of items that is always sorted into increasing order. When
adding an item to the list, we can use a <span class="classname">ListIterator</span> to find the
position in the list where the item should be added.  Once the position has been
found, we use the same list iterator to place the item in that position.
The idea is to start at
the beginning of the list and to move the iterator forward past all the items
that are smaller than the item that is being inserted. At that point, the
iterator's <span class="code">add()</span> method can be used to insert the item.
To be more definite, suppose that
<span class="code">stringList</span> is a variable of type <span class="classname">List&lt;String&gt;</span>.
Assume that that the strings that are already in the list are stored in
ascending order and that <span class="code">newItem</span> is a string that we would
like to insert into the list.  The following code will place <span class="code">newItem</span>
in the list in its correct position, so that the modified list is still in
ascending order:</p>


<pre>ListIterator&lt;String&gt; iter = stringList.listIterator();

// Move the iterator so that it points to the position where
// newItem should be inserted into the list.  If newItem is
// bigger than all the items in the list, then the while loop
// will end when iter.hasNext() becomes false, that is, when
// the iterator has reached the end of the list.

while (iter.hasNext()) {
   String item = iter.next();
   if (newItem.compareTo(item) &lt;= 0) {
         // newItem should come BEFORE item in the list.
         // Move the iterator back one space so that
         // it points to the correct insertion point,
         // and end the loop.
      iter.previous();
      break;
   } 
}

iter.add(newItem);</pre>


<p>Here, <span class="code">stringList</span> might be of type <span class="classname">ArrayList&lt;String&gt;</span>
or of type <span class="classname">LinkedList&lt;String&gt;</span>.  The
algorithm that is used to insert <span class="code">newItem</span> into the list will be
about equally efficient for both types of lists, and it will even work for other classes that
implement the interface <span class="classname">List&lt;String&gt;</span>.
You would probably find it
easier to design an insertion algorithm that uses array-like indexing with
the methods <span class="code">get(index)</span> and <span class="code">add(index,obj)</span>. However, that
algorithm would be horribly inefficient for <span class="classname">LinkedLists</span> because
random access is so inefficient for linked lists.  (By the way, the insertion 
algorithm works when the list is empty.  It might be useful
for you to think about why this is true.)</p>



   

<hr class="break">
<h3 class="subsection_title">
<a name="generics.2.2">10.2.2&nbsp;&nbsp;Sorting</a>
</h3>
   

<p>Sorting a list is a fairly common operation, and there should really be a
sorting method in the <span class="classname">List</span> interface. There is not,
presumably because it only makes sense to sort lists of certain types of objects,
but methods for sorting lists are available as <span class="code">static</span> methods
in the class <span class="code">java.util.Collections</span>. This class contains a variety of
static utility methods for working with collections.  The methods are generic;
that is, they will work for collections of objects of various types.
Suppose that <span class="code">list</span> is of type <span class="classname">List&lt;T&gt;</span>.
The command</p>


<pre>Collections.sort(list);</pre>


<p>can be used to sort the list into ascending order.  The items in the list should
implement the interface <span class="classname">Comparable&lt;T&gt;</span> 
(see <a href="../c10/s1.html#generics.1.6">Subsection&nbsp;10.1.6</a>). 
The method <span class="code">Collections.sort()</span> will work, for
example, for lists of <span class="classname">String</span> and for lists
of any of the wrapper classes such as <span class="classname">Integer</span> and
<span class="classname">Double</span>.  There is also a sorting method that takes
a <span class="classname">Comparator</span> as its second argument:</p>


<pre>Collections.sort(list,comparator);</pre>


<p>In this method, the <span class="code">comparator</span> will be used to compare the items in the list. As
mentioned in the <a href="../c10/s1.html#generics.1.6">previous section</a>,
a <span class="classname">Comparator</span> is an object that
defines a <span class="code">compare()</span> method that can be used to compare two objects.
We'll see an example of using a <span class="classname">Comparator</span> in
<a href="../c10/s4.html">Section&nbsp;10.4</a>.</p>
   

<p>The sorting method that is used by <span class="code">Collections.sort()</span> is the
so-called "merge sort" algorithm, which has both worst-case
and average-case run times that are Θ(n*log(n)) for a list of size&nbsp;n.
Although the average run time for MergeSort is a little slower than that of
QuickSort, its worst-case performance is much better than QuickSort's.
(QuickSort was covered in <a href="../c9/s1.html#recursion.1.3">Subsection&nbsp;9.1.3</a>.)
MergeSort also has a nice property called "stability" that we will encounter
at the end of <a href="../c10/s4.html#generics.4.3">Subsection&nbsp;10.4.3</a>.</p>


<p>The <span class="classname">Collections</span> class has at least two other useful methods for
modifying lists. <span class="code">Collections.shuffle(list)</span> will rearrange the elements
of the list into a random order. <span class="code">Collections.reverse(list)</span> will
reverse the order of the elements, so that the last element is moved to the
beginning of the list, the next-to-last element to the second position, and so
on.</p>


<p>Since an efficient sorting method is provided for <span class="classname">Lists</span>, there is
no need to write one yourself. You might be wondering whether there is an
equally convenient method for standard arrays. The answer is yes. Array-sorting
methods are available as static methods in the class <span class="code">java.util.Arrays</span>.
The statement</p>


<pre>Arrays.sort(A);</pre>


<p>will sort an array, <span class="code">A</span>, provided either that the base type of
<span class="code">A</span> is one of the primitive types (except <span class="ptype">boolean</span>) or that <span class="code">A</span> is
an array of <span class="classname">Objects</span> that implement the <span class="code">Comparable</span> interface.
You can also sort part of an array. This is important since arrays are often
only "partially filled." The command:</p>


<pre>Arrays.sort(A,fromIndex,toIndex);</pre>


<p>sorts the elements <span class="code">A[fromIndex]</span>, <span class="code">A[fromIndex+1]</span>, ..., <span class="code">A[toIndex-1]</span>
into ascending order. You can use <span class="code">Arrays.sort(A,0,N-1)</span> to sort a
partially filled array which has items in the first <span class="code">N</span>
positions.</p>


<p>Java does not support generic programming for primitive types. In order to
implement the command <span class="code">Arrays.sort(A)</span>, the <span class="code">Arrays</span> class
contains eight methods: one method for arrays of <span class="classname">Objects</span> and one
method for each of the primitive types <span class="ptype">byte</span>, <span class="ptype">short</span>,
<span class="ptype">int</span>, <span class="ptype">long</span>, <span class="ptype">float</span>, <span class="ptype">double</span>, and
<span class="ptype">char</span>.</p>


   
   

<hr class="break">
<h3 class="subsection_title">
<a name="generics.2.3">10.2.3&nbsp;&nbsp;TreeSet and HashSet</a>
</h3>
   

<p>A set is a collection of objects in which no object occurs more
than once. Sets implement all the methods in the interface 
<span class="classname">Collection&lt;T&gt;</span>, but do so
in a way that ensures that no element occurs twice in the set. For example, if
<span class="code">set</span> is an object of type <span class="classname">Set&lt;T&gt;</span>, 
then <span class="code">set.add(obj)</span> will
have no effect on the set if <span class="code">obj</span> is already an element of the set.
Java has two classes that implement the interface <span class="classname">Set&lt;T&gt;</span>:
<span class="code">java.util.TreeSet</span> and <span class="code">java.util.HashSet</span>.</p>


<p>In addition to being a <span class="classname">Set</span>, a <span class="classname">TreeSet</span> has the property
that the elements of the set are arranged into ascending sorted order. An
<span class="classname">Iterator</span> (or a for-each loop) 
for a <span class="code">TreeSet</span> will always visit the elements of the
set in ascending order.</p>


<p>A <span class="classname">TreeSet</span> cannot hold arbitrary objects, since there must be a way
to determine the sorted order of the objects it contains. Ordinarily, this
means that the objects in a set of type <span class="classname">TreeSet&lt;T&gt;</span> should implement the
interface <span class="classname">Comparable&lt;T&gt;</span>
and that <span class="code">obj1.compareTo(obj2)</span> should be
defined in a reasonable way for any two objects <span class="code">obj1</span> and <span class="code">obj2</span>
in the set. Alternatively, an object of type
<span class="classname">Comparator&lt;T&gt;</span> can be provided as a parameter
to the constructor when the <span class="classname">TreeSet</span> is created. In that case, the
<span class="code">compareTo()</span> method of the
<span class="classname">Comparator</span> will be used to compare objects that are added to the
set.</p>
   

<p>A <span class="classname">TreeSet</span> does not use the <span class="code">equals()</span> method to
test whether two objects are the same.  Instead, it uses the <span class="code">compareTo()</span>
method.  This can be a problem.  Recall from <a href="../c10/s1.html#generics.1.6">Subsection&nbsp;10.1.6</a> that
<span class="code">compareTo()</span> can consider two objects to be the same for the purpose
of the comparison even though the objects are not equal.  For a <span class="classname">TreeSet</span>,
this means that only <b>one</b> of those objects can be in the set.  For example,
if the <span class="classname">TreeSet</span> contains mailing addresses
and if the <span class="code">compareTo()</span> method
for addresses just compares their zip codes, then the set can contain only
one address in each zip code.  Clearly, this is not right!  But that only means
that you have to be aware of the semantics of <span class="classname">TreeSets</span>,
and you need to make sure that <span class="code">compareTo()</span> is defined in a reasonable
way for objects that you put into a <span class="classname">TreeSet</span>.  This will be
true, by the way, for <span class="classname">Strings</span>, <span class="classname">Integers</span>,
and many other built-in types, since the <span class="code">compareTo()</span> method for these
types considers two objects to be the same only if they are actually equal.</p>


<p>In the implementation of a <span class="classname">TreeSet</span>, the elements are stored in
something similar to a binary sort tree. (See <a href="../c9/s4.html#recursion.4.2">Subsection&nbsp;9.4.2</a>.) 
However, the data structure that is used is <b>balanced</b> 
in the sense that all the leaves of the tree are at
about the same distance from the root of the tree.  This ensures that
all the basic operations -- inserting, deleting, and searching -- are
efficient, with worst-case run time Θ(log(n)), where n is the
number of items in the set.</p>


<p>The fact that a <span class="classname">TreeSet</span> sorts its elements and removes duplicates
makes it very useful in some applications. <a href="../c7/ex6-ans.html">Exercise&nbsp;7.6</a> asked
you to write a program that would read a file and output an alphabetical list of
all the words that occurred in the file, with duplicates removed.  The words
were to be stored in an <span class="classname">ArrayList</span>, so it was up to you to
make sure that the list was sorted and contained no duplicates.
The same task can be programmed much more easily using a <span class="classname">TreeSet</span>
instead of a list.  A <span class="classname">TreeSet</span> automatically eliminates
duplicates, and an iterator for the set will automatically visit the items in
the set in sorted order.  An algorithm for the program, using
a <span class="classname">TreeSet</span>, would be:</p>


<pre>TreeSet&lt;String&gt; words = new TreeSet&lt;String&gt;();

while there is more data in the input file:
   Let word = the next word from the file
   Convert word to lower case
   words.add(word)   // Adds the word only if not already present.

for ( String w : words ) // for each String w in words
   Output w</pre>


<p>If you would like to see a complete, working program, you can find it in the
file <span class="sourceref"><a href="../source/WordListWithTreeSet.java">WordListWithTreeSet.java</a></span>.</p>


<p>As another example, suppose that <span class="code">coll</span> is any <span class="code">Collection</span> of
<span class="classname">Strings</span>. (This would also work for any other type for which 
<span class="code">compareTo()</span> is properly
defined.) We can use a <span class="classname">TreeSet</span> to sort the items of <span class="code">coll</span> and
remove the duplicates simply by saying:</p>


<pre>TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();
set.addAll(coll);</pre>


<p>The second statement adds all the elements of the collection to the set.
Since it's a <span class="classname">Set</span>, duplicates are ignored. Since it's a
<span class="classname">TreeSet</span>, the elements of the set are sorted. If you would like to have
the data in some other type of data structure, it's easy to copy the data from
the set. For example, to place the answer in an <span class="classname">ArrayList</span>, you could
say:</p>


<pre>TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();
set.addAll(coll);
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.addAll(set);</pre>


<p>Now, in fact, every one of Java's collection classes has a constructor that
takes a <span class="classname">Collection</span> as an argument. All the items in that
<span class="classname">Collection</span> are added to the new collection when it is created. So,
if <span class="code">coll</span> is of type <span class="classname">Collection&lt;String&gt;</span>, then
"<span class="code">new&nbsp;TreeSet&lt;String&gt;(coll)</span>" creates a <span class="classname">TreeSet</span> 
that contains the same elements as <span class="code">coll</span>, but with duplicates removed and
in sorted order.  This means that we can
abbreviate the four lines in the above example to the single command:</p>


<pre>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;( new TreeSet&lt;String&gt;(coll) );</pre>


<p>This makes a sorted list of the elements of <span class="code">coll</span> with no
duplicates. Although the repeated type parameter, "<span class="code">&lt;String&gt;</span>", makes
it a bit ugly to look at, this is still
a nice example of the power of generic programming. (It seems, by
the way, there is no equally easy way to get a sorted list <b>with</b> duplicates.
To do this, we would need something like a <span class="classname">TreeSet</span> that allows
duplicates. The C++ programming language has such a thing and refers to it as a
<span class="newword">multiset</span>. The Smalltalk language has something
similar and calls it a <span class="newword">bag</span>. Java, for the time
being at least, lacks this data type.)</p>


<hr class="break">


<p>A <span class="classname">HashSet</span> stores its elements in a <span class="newword">hash table</span>, 
a type of data structure that I will discuss in the <a href="../c10/s3.html">next
section</a>. The operations of finding, adding, and removing
elements are implemented very efficiently in hash tables, even more so than for
<span class="classname">TreeSets</span>. The elements of a <span class="classname">HashSet</span> are not stored in any
particular order, and so do not need to implement the <span class="classname">Comparable</span> interface.
(They do, however, need to define a proper "hash code," as we'll see in the next section.)</p>


<p>The <span class="code">equals()</span> method is used to determine whether two objects in
a <span class="classname">HashSet</span> are to be considered the same.
An <span class="classname">Iterator</span> for a <span class="classname">HashSet</span> will visit its
elements in what seems to be a completely arbitrary order, and it's possible
for the order to change completely when a new element is added. 
Use a <span class="classname">HashSet</span> instead of a
<span class="classname">TreeSet</span> when the elements it contains are not comparable, or when the
order is not important, or when the small advantage in efficiency is important.</p>


<hr class="break">
   

<p>A note about the mathematics of sets:  In mathematical set theory, the items in a
set are called <span class="newword">members</span> or <span class="newword">elements</span> of that set.
Important operations include adding an element to a set, removing an element from a
set, and testing whether a given entity is an element of a set.
Operations that can be performed on two sets include <span class="newword">union</span>,
<span class="newword">intersection</span>, and <span class="newword">set difference</span>.
All these operations are defined in Java for objects of type <span class="classname">Set</span>,
but with different names.  Suppose that <span class="code">A</span> and <span class="code">B</span> are <span class="classname">Sets</span>.
Then:</p>


<ul>

<li>
<span class="code">A.add(x)</span> <b>adds</b> the element <span class="code">x</span> to the set <span class="code">A</span>.</li>

<li>
<span class="code">A.remove(x)</span> <b>removes</b> the element <span class="code">x</span> from the set <span class="code">A</span>.</li>

<li>
<span class="code">A.contains(x)</span> <b>tests</b> whether <span class="code">x</span> is an element of the set <span class="code">A</span>.</li>

<li>
<span class="code">A.addAll(B)</span> computes the <b>union</b> of <span class="code">A</span> and <span class="code">B</span>.</li>

<li>
<span class="code">A.retainAll(B)</span> computes the <b>intersection</b> of <span class="code">A</span> and <span class="code">B</span>.</li>

<li>
<span class="code">A.removeAll(B)</span> computes the <b>set difference</b>, <span class="code">A - B</span>.</li>

</ul>
   

<p>There are of course, differences between mathematical sets and sets in Java.
Most important, perhaps, sets in Java must be finite, while in mathematics, most of
the fun in set theory comes from working with infinity.  In mathematics, a set can
contain arbitrary elements, while in Java, a set of type <span class="classname">Set&lt;T&gt;</span>
can only contain elements of type <span class="classname">T</span>.  The operation
<span class="code">A.addAll(B)</span> acts by modifying the value of <span class="code">A</span>, while in
mathematics the operation <span class="code">A</span> union <span class="code">B</span> computes a new set,
without changing the value of <span class="code">A</span> or <span class="code">B</span>.  See
<a href="../c10/ex2-ans.html">Exercise&nbsp;10.2</a> for an example of mathematical set operations in Java.</p>

   

   

<hr class="break">
<h3 class="subsection_title">
<a name="generics.2.4">10.2.4&nbsp;&nbsp;EnumSet</a>
</h3>
   

<p>Enumerated types (or "enums") were introduced in <a href="../c2/s3.html#basics.3.3">Subsection&nbsp;2.3.3</a>.  
Suppose that <span class="classname">E</span>
is an enumerated type.  Since <span class="classname">E</span> is a class, it is possible to create
objects of type <span class="classname">TreeSet&lt;E&gt;</span> and <span class="classname">HashSet&lt;E&gt;</span>.
However, because enums are so simple, trees and hash tables are not the most efficient
implementation for sets of enumerated type values.  Java provides the class
<span class="code">java.util.EnumSet</span> as an alternative way to create such sets.</p>
   

<p>Sets of enumerated type values are created using <span class="code">static</span> methods
in the class <span class="classname">EnumSet</span>.  For example, if <span class="code">e1</span>, 
<span class="code">e2</span>, and <span class="code">e3</span> are values belonging to the enumerated type
<span class="classname">E</span>, then the method</p>
   

<pre>EnumSet.of( e1, e2, e3 )</pre>
   

<p>creates and returns a set of type <span class="classname">EnumSet&lt;E&gt;</span> that
contains exactly the elements <span class="code">e1</span>, <span class="code">e2</span>, and <span class="code">e3</span>.
The set implements the interface <span class="classname">Set&lt;E&gt;</span>, so all
the usual set and collection operations are available.  The implementation
of these operations is very efficient.  The implementation uses what is
called a <span class="classname">bit vector</span>.  A bit is a quantity that has only
two possible values, zero and one.  A set of type <span class="classname">EnumSet&lt;E&gt;</span>
is represented by a bit vector that contains one bit for each enum constant in the
enumerated type <span class="classname">E</span>; the bit corresponding to the enum
constant <span class="code">e</span> is 1 if <span class="code">e</span> is a member of the set and is
0 if <span class="code">e</span> is not a member of the set.  The bit vectors for
two sets of type <span class="classname">EnumSet&lt;E&gt;</span> can be very easily
combined to represent such operations as the union and intersection of two
sets.  The bit vector representation is feasible for <span class="classname">EnumSets</span>,
but not for other sets in Java, because an enumerated type contains only a
small finite number of enum constants.  (Java actually has a class named
<span class="classname">BitSet</span> that uses bit vectors to represent finite sets
of non-negative integers, but this class is not part of
the Java Collection Framework and does not implement
the <span class="classname">Set</span> interface.)</p>
   

<p>The function <span class="code">EnumSet.of</span> can be used with any positive number of parameters.
All the parameters must be values of the same enumerated type.  Null values are not
allowed. An <span class="classname">EnumSet</span> cannot contain the value <span class="code">null</span> -- any
attempt to add <span class="code">null</span> to an <span class="classname">EnumSet</span> will
result in a <span class="classname">NullPointerException</span>.
</p>
   

<p>There is also a function <span class="code">EnumSet.range(e1,e2)</span> that returns an
<span class="classname">EnumSet</span> consisting of the enum constants between <span class="code">e1</span>
and <span class="code">e2</span>, inclusive.  The ordering of enum constants is the same as
the order in which they are listed in the definition of the enum.
In <span class="code">EnumSet.range(e1,e2)</span>, <span class="code">e1</span> and <span class="code">e2</span> must
belong to the same enumerated type, and <span class="code">e1</span> must be less than or
equal to <span class="code">e2</span>.</p>
   

<p>If <span class="classname">E</span> is an enum, then <span class="code">EnumSet.allOf(E.class)</span>
is a set that contains all values of type <span class="classname">E</span>.
<span class="code">EnumSet.noneOf(E.class)</span> is an <span class="newword">empty set</span>,
a set of type <span class="classname">EnumSet&lt;E&gt;</span> that contains no elements at all.
Note that in <span class="code">EnumSet.allOf(E.class)</span> and <span class="code">EnumSet.noneOf(E.class)</span>,
the odd-looking parameter represents the enumerated type class itself.  If <span class="code">eset</span> is a set of
type <span class="classname">EnumSet&lt;E&gt;</span>, then <span class="code">EnumSet.complementOf(eset)</span>
is a set that contains all the enum constants of <span class="classname">E</span> that
are <b>not</b> in <span class="code">eset</span>.</p>


<p>As an example, consider a program that keeps schedules of events.  The program
must keep track of repeating events that happen on specified days of the week.
For example, an event might take place only on weekdays, or only on
Wednesdays and Fridays.  In other words, associated with the event is
the <b>set</b> of days of the week on which it takes place.  This information
can be represented using the enumerated type</p>
   

<pre>enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY }</pre>
   

<p>The days of the week on which an event takes place would then be a value
of type <span class="classname">EnumSet&lt;Day&gt;</span>.  An object of type
<span class="classname">RepeatingEvent</span> would have an instance variable of type
<span class="classname">EnumSet&lt;Day&gt;</span> to hold this information.
An event that takes place on Wednesdays and Fridays would have the associated set</p>
   

<pre>EnumSet.of( Day.WEDNESDAY, Day.FRIDAY )</pre>
   

<p>We could define some common sets of <span class="classname">Days</span> as</p>


<pre>EnumSet&lt;Day&gt; weekday = EnumSet.range( Day.MONDAY, Day.FRIDAY );
EnumSet&lt;Day&gt; weekend = EnumSet.complementOf( weekday );
EnumSet&lt;Day&gt; everyday = EnumSet.allOf( Day.class );</pre>
   

<p>
<span class="classname">EnumSets</span> are often used to specify sets of
"options" that are to be applied during some type of processing.  For example,
a program that draws characters in fancy fonts might have various options that
can be applied.  Let's say that the options are bold, italic, underlined, strikethrough,
and boxed.  Note that we are assuming that options can be combined in arbitrary
ways.  For example, you can have italic, boxed, underlined characters. This
just means that we need to keep track of a <b>set</b> of options.  If the
options are represented by the enumerated type
</p>


<pre>enum FontOption { BOLD, ITALIC, UNDERLINED, STRIKETHROUGH, BOXED }</pre>


<p>then a set of options is represented by a value of type 
<span class="classname">EnumSet&lt;FontOption&gt;</span>.  Suppose that
<span class="code">options</span> is a variable of this type that represents the
set of options that are currently being applied by the program.
Then we can do things like:</p>
   

<ul>

<li>
<span class="code">options = EnumSet.noneOf( FontOption.class )</span>  --  Turn off all options.</li>

<li>
<span class="code">options = EnumSet.of( FontOption.BOLD )</span>  --  Use bold, with no other options.</li>

<li>
<span class="code">options.add( FontOption.BOLD )</span>  --  Add bold to any options that are already on.</li>

<li>
<span class="code">options.remove( FontOption.UNDERLINED )</span>  --  Turn underlining off (if it's on).</li>

</ul>
   

<p>This is a nice, safe way to work with sets of options. Applications like
this are one of the major reasons that enumerated types were introduced.</p>
   



</div>
<hr>
<div align="right">
<small>
        [  <a href="s1.html">Previous Section</a> |
           <a href="s3.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
